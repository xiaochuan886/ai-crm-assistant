---
title: "安全加固 - CSP 配置、Token 管理、沙箱隔离"
description: "全面加强前端Widget的安全性，实现CSP内容安全策略、安全的Token管理机制、沙箱隔离环境，确保在各种部署场景下的数据安全和访问控制"
date: "2025-10-07T05:19:46Z"
epic: "frontend-widget-architecture"
status: "pending"
priority: "high"
estimated_hours: 35
dependencies: ["001", "002", "003", "004", "005", "006"]
parallel: true
tags: ["security", "csp", "token-management", "sandbox", "frontend"]
assignee: ""
---

## 任务概述

构建全面的前端安全防护体系，通过实施严格的内容安全策略（CSP）、安全的Token管理机制、沙箱隔离环境等措施，保护用户数据和系统安全，防止XSS、CSRF等常见Web安全攻击，确保Widget在各种集成环境中的安全运行。

## 验收标准

### 安全要求
- [ ] 实现严格的CSP策略，防止代码注入攻击
- [ ] 安全的Token生命周期管理（生成、存储、使用、销毁）
- [ ] iframe沙箱隔离，防止跨域攻击
- [ ] 防XSS和CSRF攻击机制
- [ ] 敏感数据加密和安全传输

### 合规要求
- [ ] 符合OWASP Top 10安全标准
- [ ] GDPR数据保护合规
- [ ] 安全漏洞扫描通过
- [ ] 第三方安全审计通过
- [ ] 安全日志和监控完善

### 性能要求
- [ ] 安全机制不影响用户体验
- [ ] Token验证响应时间 < 200ms
- [ ] 加解密性能优化
- [ ] 安全检查不阻塞正常操作

## 详细需求

### 1. 内容安全策略（CSP）

#### 1.1 CSP策略配置
```typescript
// CSP配置管理
interface CSPPolicy {
  'default-src': string[];
  'script-src': string[];
  'style-src': string[];
  'img-src': string[];
  'connect-src': string[];
  'font-src': string[];
  'frame-src': string[];
  'frame-ancestors': string[];
  'form-action': string[];
  'base-uri': string[];
  'object-src': string[];
  'media-src': string[];
  'manifest-src': string[];
}

class CSPManager {
  private policy: CSPPolicy = {
    'default-src': ["'self'"],
    'script-src': ["'self'", "'unsafe-inline'", "'unsafe-eval'"], // 开发环境
    'style-src': ["'self'", "'unsafe-inline'"],
    'img-src': ["'self'", "data:", "https:"],
    'connect-src': ["'self'", "https://api.example.com"],
    'font-src': ["'self'", "data:"],
    'frame-src': ["'none'"],
    'frame-ancestors': ["'none'"],
    'form-action': ["'self'"],
    'base-uri': ["'self'"],
    'object-src': ["'none'"],
    'media-src': ["'self'"],
    'manifest-src': ["'self'"]
  };

  // 生产环境严格策略
  private productionPolicy: CSPPolicy = {
    'default-src': ["'self'"],
    'script-src': ["'self'"], // 移除unsafe-inline和unsafe-eval
    'style-src': ["'self'"],
    'img-src': ["'self'", "https:"],
    'connect-src': ["'self'", "https://api.example.com"],
    'font-src': ["'self'"],
    'frame-src': ["'none'"],
    'frame-ancestors': ["'none'"],
    'form-action': ["'self'"],
    'base-uri': ["'self'"],
    'object-src': ["'none'"],
    'media-src': ["'self'"],
    'manifest-src': ["'self'"]
  };

  generateCSPHeader(isProduction: boolean = false): string {
    const policy = isProduction ? this.productionPolicy : this.policy;
    return Object.entries(policy)
      .map(([directive, sources]) => `${directive} ${sources.join(' ')}`)
      .join('; ');
  }

  // 动态CSP更新
  updatePolicy(directive: keyof CSPPolicy, sources: string[]): void {
    this.policy[directive] = sources;
  }

  // CSP违规报告
  handleViolationReport(report: CSPViolationReport): void {
    console.warn('CSP Violation:', report);
    // 发送到安全监控系统
    this.reportViolation(report);
  }
}

// CSP违规报告接口
interface CSPViolationReport {
  blockedURI: string;
  documentURI: string;
  effectiveDirective: string;
  originalPolicy: string;
  referrer: string;
  sourceFile: string;
  statusCode: number;
  violatedDirective: string;
}
```

#### 1.2 动态CSP和Nonce
```typescript
// Nonce生成和管理
class NonceManager {
  private nonces = new Map<string, { nonce: string; expires: number }>();

  generateNonce(context: string = 'default'): string {
    const nonce = this.randomBase64(16);
    const expires = Date.now() + 5 * 60 * 1000; // 5分钟过期

    this.nonces.set(context, { nonce, expires });
    return nonce;
  }

  validateNonce(context: string, nonce: string): boolean {
    const stored = this.nonces.get(context);
    if (!stored) return false;

    if (Date.now() > stored.expires) {
      this.nonces.delete(context);
      return false;
    }

    return stored.nonce === nonce;
  }

  private randomBase64(length: number): string {
    const array = new Uint8Array(length);
    crypto.getRandomValues(array);
    return btoa(String.fromCharCode(...array));
  }

  // 清理过期nonce
  cleanup(): void {
    const now = Date.now();
    for (const [context, data] of this.nonces.entries()) {
      if (now > data.expires) {
        this.nonces.delete(context);
      }
    }
  }
}

// 动态脚本加载
const loadScriptWithNonce = (src: string, nonce: string): Promise<void> => {
  return new Promise((resolve, reject) => {
    const script = document.createElement('script');
    script.src = src;
    script.nonce = nonce;
    script.onload = () => resolve();
    script.onerror = reject;
    document.head.appendChild(script);
  });
};
```

### 2. Token安全管理

#### 2.1 Token生命周期管理
```typescript
// Token管理器
class TokenManager {
  private token: string | null = null;
  private refreshToken: string | null = null;
  private tokenExpiry: number = 0;
  private readonly TOKEN_KEY = 'crm_widget_token';
  private readonly REFRESH_TOKEN_KEY = 'crm_widget_refresh_token';

  // 安全存储Token
  async storeToken(token: string, expiresIn: number): Promise<void> {
    try {
      // 使用加密存储
      const encryptedToken = await this.encrypt(token);
      localStorage.setItem(this.TOKEN_KEY, encryptedToken);

      this.token = token;
      this.tokenExpiry = Date.now() + expiresIn * 1000;

      // 设置自动刷新
      this.scheduleRefresh(expiresIn * 0.8); // 80%时间后刷新
    } catch (error) {
      console.error('Token storage failed:', error);
      throw new Error('Failed to store token securely');
    }
  }

  // 获取Token
  async getToken(): Promise<string | null> {
    if (this.token && this.isTokenValid()) {
      return this.token;
    }

    // 尝试从存储恢复
    const stored = localStorage.getItem(this.TOKEN_KEY);
    if (stored) {
      try {
        const decryptedToken = await this.decrypt(stored);
        this.token = decryptedToken;
        return decryptedToken;
      } catch (error) {
        console.error('Token decryption failed:', error);
        this.clearToken();
      }
    }

    return null;
  }

  // Token验证
  isTokenValid(): boolean {
    return this.token !== null && Date.now() < this.tokenExpiry;
  }

  // Token刷新
  async refreshTokenIfNeeded(): Promise<boolean> {
    if (!this.isTokenValid()) {
      return this.refreshToken();
    }
    return true;
  }

  private async refreshToken(): Promise<boolean> {
    try {
      const response = await fetch('/api/auth/refresh', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          refreshToken: this.refreshToken
        })
      });

      if (response.ok) {
        const { token, expiresIn } = await response.json();
        await this.storeToken(token, expiresIn);
        return true;
      }
    } catch (error) {
      console.error('Token refresh failed:', error);
    }

    // 刷新失败，清除Token
    this.clearToken();
    return false;
  }

  // 安全清除Token
  clearToken(): void {
    this.token = null;
    this.refreshToken = null;
    this.tokenExpiry = 0;
    localStorage.removeItem(this.TOKEN_KEY);
    localStorage.removeItem(this.REFRESH_TOKEN_KEY);
  }

  // 加密/解密
  private async encrypt(data: string): Promise<string> {
    const key = await this.getEncryptionKey();
    const iv = crypto.getRandomValues(new Uint8Array(12));

    const encrypted = await crypto.subtle.encrypt(
      { name: 'AES-GCM', iv },
      key,
      new TextEncoder().encode(data)
    );

    return btoa(String.fromCharCode(...new Uint8Array(iv), ...new Uint8Array(encrypted)));
  }

  private async decrypt(encryptedData: string): Promise<string> {
    const key = await this.getEncryptionKey();
    const data = Uint8Array.from(atob(encryptedData), c => c.charCodeAt(0));

    const iv = data.slice(0, 12);
    const encrypted = data.slice(12);

    const decrypted = await crypto.subtle.decrypt(
      { name: 'AES-GCM', iv },
      key,
      encrypted
    );

    return new TextDecoder().decode(decrypted);
  }

  private async getEncryptionKey(): Promise<CryptoKey> {
    const keyMaterial = await crypto.subtle.importKey(
      'raw',
      new TextEncoder().encode('crm-widget-secret-key'),
      { name: 'PBKDF2' },
      false,
      ['deriveBits', 'deriveKey']
    );

    return crypto.subtle.deriveKey(
      {
        name: 'PBKDF2',
        salt: new TextEncoder().encode('crm-widget-salt'),
        iterations: 100000,
        hash: 'SHA-256'
      },
      keyMaterial,
      { name: 'AES-GCM', length: 256 },
      false,
      ['encrypt', 'decrypt']
    );
  }

  private scheduleRefresh(delaySeconds: number): void {
    setTimeout(() => {
      this.refreshToken();
    }, delaySeconds * 1000);
  }
}
```

#### 2.2 Token传递和验证
```typescript
// 安全Token传递
class SecureTokenHandler {
  private tokenManager: TokenManager;

  constructor() {
    this.tokenManager = new TokenManager();
  }

  // PostMessage安全处理
  setupSecureMessaging(targetOrigin: string): void {
    window.addEventListener('message', async (event) => {
      // 验证消息来源
      if (event.origin !== targetOrigin) {
        console.warn('Unauthorized message origin:', event.origin);
        return;
      }

      const { type, data, nonce } = event.data;

      // 验证消息类型和结构
      if (type === 'TOKEN_EXCHANGE' && this.isValidTokenData(data)) {
        try {
          // 验证nonce防止重放攻击
          if (this.validateNonce(nonce)) {
            await this.tokenManager.storeToken(data.token, data.expiresIn);

            // 确认接收
            event.source?.postMessage({
              type: 'TOKEN_RECEIVED',
              nonce: nonce
            }, targetOrigin);
          }
        } catch (error) {
          console.error('Token handling failed:', error);
        }
      }
    });
  }

  // HTTP请求Token注入
  async addTokenToHeaders(headers: Record<string, string>): Promise<Record<string, string>> {
    const token = await this.tokenManager.getToken();

    if (token) {
      return {
        ...headers,
        'Authorization': `Bearer ${token}`,
        'X-Requested-With': 'XMLHttpRequest'
      };
    }

    return headers;
  }

  // Token数据验证
  private isValidTokenData(data: any): boolean {
    return data &&
           typeof data.token === 'string' &&
           typeof data.expiresIn === 'number' &&
           data.token.length > 0;
  }

  // Nonce验证
  private validateNonce(nonce: string): boolean {
    const usedNonces = JSON.parse(sessionStorage.getItem('used_nonces') || '[]');

    if (usedNonces.includes(nonce)) {
      return false; // 重放攻击
    }

    usedNonces.push(nonce);
    sessionStorage.setItem('used_nonces', JSON.stringify(usedNonces.slice(-100))); // 保留最近100个

    return true;
  }
}
```

### 3. 沙箱隔离

#### 3.1 iframe沙箱配置
```typescript
// 沙箱管理器
class SandboxManager {
  private iframe: HTMLIFrameElement | null = null;
  private sandboxPolicies = [
    'allow-scripts',           // 允许JavaScript
    'allow-same-origin',       // 允许同源请求
    'allow-forms',            // 允许表单提交
    'allow-popups',           // 允许弹出窗口
    'allow-modals',           // 允许模态框
    // 'allow-top-navigation', // 禁止顶层导航
    // 'allow-popups-to-escape-sandbox', // 禁止弹出窗口逃脱沙箱
  ];

  createSandbox(container: HTMLElement, src: string): HTMLIFrameElement {
    const iframe = document.createElement('iframe');

    // 设置沙箱属性
    iframe.sandbox = this.sandboxPolicies.join(' ');

    // 安全属性
    iframe.referrerPolicy = 'no-referrer-when-downgrade';
    iframe.loading = 'lazy';

    // CSP元标签
    const cspMeta = `<meta http-equiv="Content-Security-Policy" content="${this.generateCSPForSandbox()}">`;

    // 创建沙箱文档
    const sandboxHTML = `
      <!DOCTYPE html>
      <html>
        <head>
          ${cspMeta}
          <meta charset="utf-8">
          <meta name="viewport" content="width=device-width, initial-scale=1">
          <title>CRM Widget</title>
        </head>
        <body>
          <div id="root"></div>
          <script src="${src}"></script>
        </body>
      </html>
    `;

    iframe.srcdoc = sandboxHTML;
    container.appendChild(iframe);

    this.iframe = iframe;
    this.setupSandboxCommunication();

    return iframe;
  }

  private generateCSPForSandbox(): string {
    return [
      "default-src 'self'",
      "script-src 'self' 'unsafe-inline'",
      "style-src 'self' 'unsafe-inline'",
      "img-src 'self' data: https:",
      "connect-src 'self' https://api.example.com",
      "font-src 'self'",
      "frame-src 'none'",
      "object-src 'none'"
    ].join('; ');
  }

  // 安全通信设置
  private setupSandboxCommunication(): void {
    if (!this.iframe) return;

    const secureChannel = new MessageChannel();

    // 端口1发送给iframe
    this.iframe.contentWindow?.postMessage({
      type: 'SANDBOX_INIT',
      port: secureChannel.port2
    }, '*', [secureChannel.port2]);

    // 端口0保留在父窗口
    secureChannel.port1.onmessage = (event) => {
      this.handleSandboxMessage(event.data);
    };
  }

  private handleSandboxMessage(data: any): void {
    // 验证和处理来自沙箱的消息
    switch (data.type) {
      case 'API_REQUEST':
        this.proxyApiRequest(data.payload);
        break;
      case 'TOKEN_REQUEST':
        this.handleTokenRequest(data.payload);
        break;
      default:
        console.warn('Unknown sandbox message type:', data.type);
    }
  }

  // 代理API请求
  private async proxyApiRequest(payload: any): Promise<void> {
    try {
      const response = await fetch(payload.url, {
        method: payload.method,
        headers: await this.addSecureHeaders(payload.headers),
        body: payload.body
      });

      const result = await response.json();

      this.sendMessageToSandbox({
        type: 'API_RESPONSE',
        requestId: payload.requestId,
        data: result
      });
    } catch (error) {
      this.sendMessageToSandbox({
        type: 'API_ERROR',
        requestId: payload.requestId,
        error: error.message
      });
    }
  }

  private sendMessageToSandbox(message: any): void {
    this.iframe?.contentWindow?.postMessage(message, '*');
  }
}
```

#### 3.2 Web Worker沙箱
```typescript
// Web Worker安全沙箱
class WorkerSandbox {
  private worker: Worker | null = null;
  private messageQueue: Array<{resolve: Function, reject: Function, data: any}> = [];

  constructor(workerScript: string) {
    this.initWorker(workerScript);
  }

  private initWorker(workerScript: string): void {
    const blob = new Blob([workerScript], { type: 'application/javascript' });
    const workerUrl = URL.createObjectURL(blob);

    this.worker = new Worker(workerUrl);
    this.setupWorkerCommunication();
  }

  private setupWorkerCommunication(): void {
    if (!this.worker) return;

    this.worker.onmessage = (event) => {
      const { type, data, messageId } = event.data;

      if (type === 'RESPONSE' && this.messageQueue[messageId]) {
        const { resolve, reject } = this.messageQueue[messageId];

        if (data.error) {
          reject(new Error(data.error));
        } else {
          resolve(data.result);
        }

        delete this.messageQueue[messageId];
      }
    };

    this.worker.onerror = (error) => {
      console.error('Worker error:', error);
    };
  }

  // 安全执行代码
  async executeCode(code: string, context: any = {}): Promise<any> {
    return new Promise((resolve, reject) => {
      const messageId = this.messageQueue.length;

      this.messageQueue.push({ resolve, reject, data: null });

      this.worker?.postMessage({
        type: 'EXECUTE',
        messageId,
        data: {
          code: this.sanitizeCode(code),
          context: this.sanitizeContext(context)
        }
      });
    });
  }

  // 代码清理
  private sanitizeCode(code: string): string {
    // 移除危险的代码模式
    const dangerousPatterns = [
      /eval\s*\(/gi,
      /Function\s*\(/gi,
      /document\./gi,
      /window\./gi,
      /localStorage/gi,
      /sessionStorage/gi,
      /indexedDB/gi
    ];

    let sanitizedCode = code;
    dangerousPatterns.forEach(pattern => {
      sanitizedCode = sanitizedCode.replace(pattern, '/* BLOCKED */');
    });

    return sanitizedCode;
  }

  private sanitizeContext(context: any): any {
    // 移除危险属性
    const sanitized = { ...context };
    delete sanitized.window;
    delete sanitized.document;
    delete sanitized.localStorage;
    delete sanitized.sessionStorage;

    return sanitized;
  }

  terminate(): void {
    this.worker?.terminate();
    this.worker = null;
    this.messageQueue = [];
  }
}

// Worker脚本内容
const workerScript = `
  let sandboxContext = {};

  self.onmessage = function(event) {
    const { type, messageId, data } = event.data;

    if (type === 'EXECUTE') {
      try {
        // 创建安全的执行环境
        const func = new Function('context', \`
          const { console, Math, Date, JSON, RegExp, String, Number, Array, Object } = context;
          return (function() {
            \${data.code}
          })();
        \`);

        const result = func({ ...sandboxContext, ...data.context });

        self.postMessage({
          type: 'RESPONSE',
          messageId,
          data: { result }
        });
      } catch (error) {
        self.postMessage({
          type: 'RESPONSE',
          messageId,
          data: { error: error.message }
        });
      }
    } else if (type === 'UPDATE_CONTEXT') {
      sandboxContext = { ...sandboxContext, ...data.context };
    }
  };
`;
```

### 4. XSS和CSRF防护

#### 4.1 XSS防护
```typescript
// XSS防护工具
class XSSProtection {
  private static readonly dangerousTags = [
    'script', 'iframe', 'object', 'embed', 'form', 'input', 'textarea'
  ];

  private static readonly dangerousAttributes = [
    'onload', 'onerror', 'onclick', 'onmouseover', 'onfocus', 'onblur',
    'onchange', 'onsubmit', 'onreset', 'onselect', 'onkeydown', 'onkeyup'
  ];

  // HTML内容清理
  static sanitizeHTML(html: string): string {
    const tempDiv = document.createElement('div');
    tempDiv.textContent = html;
    return tempDiv.innerHTML;
  }

  // 严格HTML清理（使用DOMPurify）
  static strictSanitizeHTML(html: string): string {
    if (typeof window !== 'undefined' && 'DOMPurify' in window) {
      return (window as any).DOMPurify.sanitize(html, {
        ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'a', 'p', 'br', 'span'],
        ALLOWED_ATTR: ['href', 'target', 'rel'],
        ALLOW_DATA_ATTR: false
      });
    }
    return this.sanitizeHTML(html);
  }

  // 输入验证
  static validateInput(input: string, type: 'text' | 'email' | 'url' | 'number'): boolean {
    const patterns = {
      text: /^[a-zA-Z0-9\s\-_,.!?()]+$/,
      email: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
      url: /^https?:\/\/[^\s/$.?#].[^\s]*$/,
      number: /^\d+$/
    };

    return patterns[type].test(input);
  }

  // 属性清理
  static sanitizeAttributes(element: HTMLElement): void {
    this.dangerousAttributes.forEach(attr => {
      element.removeAttribute(attr);
    });

    // 清理事件处理器
    const attributes = element.getAttributeNames();
    attributes.forEach(attr => {
      if (attr.startsWith('on')) {
        element.removeAttribute(attr);
      }
    });
  }
}

// 安全的HTML渲染组件
const SafeHTMLRenderer: React.FC<{ html: string }> = React.memo(({ html }) => {
  const sanitizedHTML = useMemo(() => {
    return XSSProtection.strictSanitizeHTML(html);
  }, [html]);

  return (
    <div
      dangerouslySetInnerHTML={{ __html: sanitizedHTML }}
      className="safe-html-content"
    />
  );
});
```

#### 4.2 CSRF防护
```typescript
// CSRF防护
class CSRFProtection {
  private static readonly TOKEN_LENGTH = 32;
  private static readonly TOKEN_KEY = 'csrf_token';

  // 生成CSRF Token
  static generateToken(): string {
    const array = new Uint8Array(this.TOKEN_LENGTH);
    crypto.getRandomValues(array);
    return btoa(String.fromCharCode(...array));
  }

  // 获取或创建Token
  static getToken(): string {
    let token = sessionStorage.getItem(this.TOKEN_KEY);

    if (!token) {
      token = this.generateToken();
      sessionStorage.setItem(this.TOKEN_KEY, token);
    }

    return token;
  }

  // 验证Token
  static validateToken(token: string): boolean {
    const storedToken = sessionStorage.getItem(this.TOKEN_KEY);
    return storedToken === token;
  }

  // 添加Token到请求
  static addTokenToRequest(request: RequestInit): RequestInit {
    const token = this.getToken();

    return {
      ...request,
      headers: {
        ...request.headers,
        'X-CSRF-Token': token
      }
    };
  }

  // 表单Token注入
  static injectTokenIntoForm(form: HTMLFormElement): void {
    const token = this.getToken();
    let tokenInput = form.querySelector('input[name="csrf_token"]') as HTMLInputElement;

    if (!tokenInput) {
      tokenInput = document.createElement('input');
      tokenInput.type = 'hidden';
      tokenInput.name = 'csrf_token';
      form.appendChild(tokenInput);
    }

    tokenInput.value = token;
  }
}

// 安全API客户端
class SecureAPIClient {
  private baseURL: string;

  constructor(baseURL: string) {
    this.baseURL = baseURL;
  }

  async request<T>(
    endpoint: string,
    options: RequestInit = {}
  ): Promise<T> {
    const url = `${this.baseURL}${endpoint}`;

    // 添加安全头
    const secureOptions = CSRFProtection.addTokenToRequest({
      ...options,
      headers: {
        'Content-Type': 'application/json',
        'X-Requested-With': 'XMLHttpRequest',
        ...options.headers
      },
      credentials: 'same-origin'
    });

    try {
      const response = await fetch(url, secureOptions);

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      return await response.json();
    } catch (error) {
      console.error('Secure API request failed:', error);
      throw error;
    }
  }

  async get<T>(endpoint: string): Promise<T> {
    return this.request<T>(endpoint, { method: 'GET' });
  }

  async post<T>(endpoint: string, data: any): Promise<T> {
    return this.request<T>(endpoint, {
      method: 'POST',
      body: JSON.stringify(data)
    });
  }
}
```

### 5. 安全监控和日志

#### 5.1 安全事件监控
```typescript
// 安全监控系统
class SecurityMonitor {
  private events: SecurityEvent[] = [];
  private readonly MAX_EVENTS = 1000;

  // 记录安全事件
  recordEvent(event: Partial<SecurityEvent>): void {
    const securityEvent: SecurityEvent = {
      id: this.generateEventId(),
      timestamp: Date.now(),
      type: event.type || 'UNKNOWN',
      severity: event.severity || 'low',
      source: event.source || 'unknown',
      details: event.details || {},
      userAgent: navigator.userAgent,
      url: window.location.href
    };

    this.events.push(securityEvent);

    // 保持事件队列大小
    if (this.events.length > this.MAX_EVENTS) {
      this.events.shift();
    }

    // 高危事件立即上报
    if (securityEvent.severity === 'high' || securityEvent.severity === 'critical') {
      this.reportEvent(securityEvent);
    }
  }

  // 检测异常行为
  detectAnomalies(): void {
    // 检测快速连续请求
    this.detectRapidRequests();

    // 检测异常错误模式
    this.detectErrorPatterns();

    // 检测Token异常
    this.detectTokenAnomalies();
  }

  private detectRapidRequests(): void {
    const recentEvents = this.events.filter(
      event => Date.now() - event.timestamp < 60000 && event.type === 'API_REQUEST'
    );

    if (recentEvents.length > 100) {
      this.recordEvent({
        type: 'RAPID_REQUESTS',
        severity: 'medium',
        source: 'behavior_analysis',
        details: { count: recentEvents.length }
      });
    }
  }

  private detectErrorPatterns(): void {
    const errorEvents = this.events.filter(
      event => Date.now() - event.timestamp < 300000 && event.type === 'ERROR'
    );

    // 检测相同错误频繁出现
    const errorCounts = errorEvents.reduce((acc, event) => {
      const key = event.details.error || 'unknown';
      acc[key] = (acc[key] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    Object.entries(errorCounts).forEach(([error, count]) => {
      if (count > 10) {
        this.recordEvent({
          type: 'REPEATED_ERROR',
          severity: 'medium',
          source: 'error_analysis',
          details: { error, count }
        });
      }
    });
  }

  private detectTokenAnomalies(): void {
    const tokenEvents = this.events.filter(
      event => Date.now() - event.timestamp < 3600000 && event.type.includes('TOKEN')
    );

    // 检测Token频繁刷新
    const refreshEvents = tokenEvents.filter(e => e.type === 'TOKEN_REFRESH');
    if (refreshEvents.length > 5) {
      this.recordEvent({
        type: 'EXCESSIVE_TOKEN_REFRESH',
        severity: 'high',
        source: 'token_analysis',
        details: { count: refreshEvents.length }
      });
    }
  }

  // 事件上报
  private async reportEvent(event: SecurityEvent): Promise<void> {
    try {
      await fetch('/api/security/events', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(event)
      });
    } catch (error) {
      console.error('Failed to report security event:', error);
    }
  }

  private generateEventId(): string {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }

  // 获取安全报告
  getSecurityReport(): SecurityReport {
    const now = Date.now();
    const last24Hours = this.events.filter(e => now - e.timestamp < 86400000);

    return {
      totalEvents: this.events.length,
      last24Hours: last24Hours.length,
      criticalEvents: last24Hours.filter(e => e.severity === 'critical').length,
      highEvents: last24Hours.filter(e => e.severity === 'high').length,
      mediumEvents: last24Hours.filter(e => e.severity === 'medium').length,
      lowEvents: last24Hours.filter(e => e.severity === 'low').length,
      eventTypes: this.getEventTypeDistribution(last24Hours),
      recommendations: this.generateRecommendations(last24Hours)
    };
  }

  private getEventTypeDistribution(events: SecurityEvent[]): Record<string, number> {
    return events.reduce((acc, event) => {
      acc[event.type] = (acc[event.type] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);
  }

  private generateRecommendations(events: SecurityEvent[]): string[] {
    const recommendations: string[] = [];

    const criticalCount = events.filter(e => e.severity === 'critical').length;
    if (criticalCount > 0) {
      recommendations.push('发现严重安全事件，建议立即检查系统状态');
    }

    const tokenRefreshEvents = events.filter(e => e.type === 'EXCESSIVE_TOKEN_REFRESH');
    if (tokenRefreshEvents.length > 0) {
      recommendations.push('Token刷新异常，建议检查认证机制');
    }

    return recommendations;
  }
}

// 安全事件接口
interface SecurityEvent {
  id: string;
  timestamp: number;
  type: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  source: string;
  details: Record<string, any>;
  userAgent: string;
  url: string;
}

interface SecurityReport {
  totalEvents: number;
  last24Hours: number;
  criticalEvents: number;
  highEvents: number;
  mediumEvents: number;
  lowEvents: number;
  eventTypes: Record<string, number>;
  recommendations: string[];
}
```

## 技术方案

### 安全架构
- **多层防护**: CSP + Token管理 + 沙箱隔离
- **纵深防御**: 前端验证 + 后端验证 + 传输加密
- **零信任**: 所有输入和交互都需要验证
- **最小权限**: 最小化代码权限和数据访问

### 安全库和工具
- **DOMPurify**: HTML清理和XSS防护
- **helmet**: Express安全头设置
- **crypto-js**: 客户端加密
- **owasp-security-headers**: 安全头配置

### 安全测试
- **自动化扫描**: OWASP ZAP, Burp Suite
- **代码审查**: 安全代码审查流程
- **渗透测试**: 第三方安全评估
- **合规检查**: GDPR, SOC2合规验证

## 开发计划

### 第1周：基础安全架构
- CSP策略配置和实施
- 基础Token管理机制
- XSS防护实现

### 第2周：沙箱隔离
- iframe沙箱配置
- Web Worker安全执行环境
- 安全通信机制

### 第3周：高级安全特性
- CSRF防护完善
- 加密存储实现
- 安全监控系统

### 第4周：测试和审计
- 安全测试套件
- 第三方安全审计
- 性能影响评估

## 风险和依赖

### 安全风险
- 过度安全可能影响用户体验
- 沙箱环境兼容性问题
- 加密性能开销

### 依赖关系
- 依赖基础组件完成
- 需要后端安全配合
- 需要安全测试环境

## 测试策略

### 安全测试
- XSS攻击测试
- CSRF攻击测试
- Token安全测试
- 沙箱逃逸测试

### 兼容性测试
- 浏览器安全特性支持
- 移动端安全验证
- 不同环境下的安全性

## 部署和监控

### 安全部署
- 渐进式安全策略部署
- 安全配置验证
- 回滚机制准备

### 持续监控
- 安全事件实时监控
- 异常行为自动检测
- 安全报告定期生成
