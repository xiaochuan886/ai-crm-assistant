---
title: "æµ‹è¯•å’Œéƒ¨ç½² - å®Œå–„æµ‹è¯•å¥—ä»¶ã€CI/CD æµç¨‹ã€ç›‘æ§ç³»ç»Ÿ"
description: "å»ºç«‹å®Œæ•´çš„æµ‹è¯•ä½“ç³»ã€CI/CDè‡ªåŠ¨åŒ–éƒ¨ç½²æµç¨‹å’Œç›‘æ§ç³»ç»Ÿï¼Œç¡®ä¿å‰ç«¯Widgetçš„è´¨é‡ã€ç¨³å®šæ€§å’Œå¯ç»´æŠ¤æ€§ï¼Œæ”¯æŒå¿«é€Ÿè¿­ä»£å’Œå¯é äº¤ä»˜"
date: "2025-10-07T05:19:46Z"
epic: "frontend-widget-architecture"
status: "pending"
priority: "high"
estimated_hours: 45
dependencies: ["001", "002", "003", "004", "005", "006"]
parallel: true
tags: ["testing", "deployment", "ci-cd", "monitoring", "quality-assurance"]
assignee: ""
---

## ä»»åŠ¡æ¦‚è¿°

æ„å»ºå…¨é¢çš„æµ‹è¯•ä½“ç³»å’ŒCI/CDæµæ°´çº¿ï¼Œå®ç°è‡ªåŠ¨åŒ–æµ‹è¯•ã€æ„å»ºã€éƒ¨ç½²å’Œç›‘æ§ã€‚ç¡®ä¿å‰ç«¯Widgetåœ¨å„ç§ç¯å¢ƒå’Œåœºæ™¯ä¸‹çš„è´¨é‡ç¨³å®šæ€§ï¼Œå»ºç«‹å®Œå–„çš„ç›‘æ§å‘Šè­¦æœºåˆ¶ï¼Œæ”¯æŒæŒç»­é›†æˆå’ŒæŒç»­éƒ¨ç½²çš„æœ€ä½³å®è·µã€‚

## éªŒæ”¶æ ‡å‡†

### æµ‹è¯•è¦æ±‚
- [ ] å•å…ƒæµ‹è¯•è¦†ç›–ç‡ > 90%
- [ ] é›†æˆæµ‹è¯•è¦†ç›–æ ¸å¿ƒä¸šåŠ¡æµç¨‹
- [ ] E2Eæµ‹è¯•è¦†ç›–å…³é”®ç”¨æˆ·åœºæ™¯
- [ ] æ€§èƒ½æµ‹è¯•è‡ªåŠ¨åŒ–æ‰§è¡Œ
- [ ] å®‰å…¨æµ‹è¯•é›†æˆåˆ°CI/CD

### éƒ¨ç½²è¦æ±‚
- [ ] CI/CDæµæ°´çº¿å®Œå…¨è‡ªåŠ¨åŒ–
- [ ] å¤šç¯å¢ƒéƒ¨ç½²æ”¯æŒï¼ˆå¼€å‘ã€æµ‹è¯•ã€é¢„ç”Ÿäº§ã€ç”Ÿäº§ï¼‰
- [ ] è“ç»¿éƒ¨ç½²å’Œå›æ»šæœºåˆ¶
- [ ] ç‰ˆæœ¬ç®¡ç†å’Œå‘å¸ƒç­–ç•¥
- [ ] éƒ¨ç½²æ—¶é—´ < 10åˆ†é’Ÿ

### ç›‘æ§è¦æ±‚
- [ ] å®æ—¶æ€§èƒ½ç›‘æ§
- [ ] é”™è¯¯è¿½è¸ªå’Œå‘Šè­¦
- [ ] ç”¨æˆ·ä½“éªŒç›‘æ§
- [ ] ä¸šåŠ¡æŒ‡æ ‡ç›‘æ§
- [ ] ç›‘æ§ä»ªè¡¨æ¿å’ŒæŠ¥å‘Š

## è¯¦ç»†éœ€æ±‚

### 1. æµ‹è¯•ä½“ç³»æ¶æ„

#### 1.1 å•å…ƒæµ‹è¯•æ¡†æ¶
```typescript
// Jest + React Testing Library é…ç½®
// jest.config.js
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'jsdom',
  setupFilesAfterEnv: ['<rootDir>/src/test/setup.ts'],
  moduleNameMapping: {
    '\.(css|less|scss|sass)$': 'identity-obj-proxy',
    '^@/(.*)$': '<rootDir>/src/$1'
  },
  collectCoverageFrom: [
    'src/**/*.{ts,tsx}',
    '!src/**/*.d.ts',
    '!src/test/**/*',
    '!src/index.tsx'
  ],
  coverageThreshold: {
    global: {
      branches: 90,
      functions: 90,
      lines: 90,
      statements: 90
    }
  },
  testMatch: [
    '<rootDir>/src/**/__tests__/**/*.{ts,tsx}',
    '<rootDir>/src/**/*.{test,spec}.{ts,tsx}'
  ]
};

// æµ‹è¯•å·¥å…·é…ç½®
// src/test/setup.ts
import '@testing-library/jest-dom';
import { configure } from '@testing-library/react';

// é…ç½®Testing Library
configure({ testIdAttribute: 'data-testid' });

// Mock IntersectionObserver
global.IntersectionObserver = jest.fn().mockImplementation(() => ({
  observe: jest.fn(),
  unobserve: jest.fn(),
  disconnect: jest.fn()
}));

// Mock ResizeObserver
global.ResizeObserver = jest.fn().mockImplementation(() => ({
  observe: jest.fn(),
  unobserve: jest.fn(),
  disconnect: jest.fn()
}));

// Mock WebSocket
global.WebSocket = jest.fn().mockImplementation(() => ({
  close: jest.fn(),
  send: jest.fn(),
  addEventListener: jest.fn(),
  removeEventListener: jest.fn()
}));
```

#### 1.2 ç»„ä»¶æµ‹è¯•ç¤ºä¾‹
```typescript
// ChatInterface.test.tsx
import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { ChatInterface } from '../ChatInterface';
import { WebSocketProvider } from '../../contexts/WebSocketContext';
import { ThemeProvider } from '../../contexts/ThemeContext';

// æµ‹è¯•å·¥å…·å‡½æ•°
const renderWithProviders = (component: React.ReactElement) => {
  return render(
    <ThemeProvider>
      <WebSocketProvider>
        {component}
      </WebSocketProvider>
    </ThemeProvider>
  );
};

// Mockæ•°æ®
const mockMessages = [
  {
    id: '1',
    content: 'Hello',
    type: 'user',
    timestamp: Date.now()
  },
  {
    id: '2',
    content: 'Hi there!',
    type: 'assistant',
    timestamp: Date.now()
  }
];

describe('ChatInterface', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('renders chat interface correctly', () => {
    renderWithProviders(<ChatInterface />);

    expect(screen.getByTestId('chat-interface')).toBeInTheDocument();
    expect(screen.getByTestId('message-input')).toBeInTheDocument();
    expect(screen.getByTestId('send-button')).toBeInTheDocument();
  });

  it('displays messages correctly', () => {
    renderWithProviders(<ChatInterface messages={mockMessages} />);

    mockMessages.forEach(message => {
      expect(screen.getByText(message.content)).toBeInTheDocument();
    });
  });

  it('sends message when send button is clicked', async () => {
    const user = userEvent.setup();
    const mockSendMessage = jest.fn();

    renderWithProviders(
      <ChatInterface onSendMessage={mockSendMessage} />
    );

    const input = screen.getByTestId('message-input');
    const sendButton = screen.getByTestId('send-button');

    await user.type(input, 'Test message');
    await user.click(sendButton);

    expect(mockSendMessage).toHaveBeenCalledWith('Test message');
    expect(input).toHaveValue('');
  });

  it('handles keyboard shortcuts', async () => {
    const user = userEvent.setup();
    const mockSendMessage = jest.fn();

    renderWithProviders(
      <ChatInterface onSendMessage={mockSendMessage} />
    );

    const input = screen.getByTestId('message-input');

    await user.type(input, 'Test message');
    await user.keyboard('{Enter}');

    expect(mockSendMessage).toHaveBeenCalledWith('Test message');
  });

  it('shows loading state', () => {
    renderWithProviders(<ChatInterface isLoading={true} />);

    expect(screen.getByTestId('loading-indicator')).toBeInTheDocument();
  });

  it('handles error states', () => {
    const error = new Error('Connection failed');

    renderWithProviders(<ChatInterface error={error} />);

    expect(screen.getByText(/connection failed/i)).toBeInTheDocument();
  });
});

// è‡ªå®šä¹‰Hookæµ‹è¯•
// hooks/useChatMessages.test.ts
import { renderHook, act } from '@testing-library/react';
import { useChatMessages } from '../useChatMessages';

describe('useChatMessages', () => {
  it('initializes with empty messages', () => {
    const { result } = renderHook(() => useChatMessages());

    expect(result.current.messages).toEqual([]);
    expect(result.current.isLoading).toBe(false);
  });

  it('adds message correctly', () => {
    const { result } = renderHook(() => useChatMessages());

    act(() => {
      result.current.addMessage({
        id: '1',
        content: 'Test message',
        type: 'user'
      });
    });

    expect(result.current.messages).toHaveLength(1);
    expect(result.current.messages[0].content).toBe('Test message');
  });

  it('clears messages correctly', () => {
    const { result } = renderHook(() => useChatMessages());

    act(() => {
      result.current.addMessage({
        id: '1',
        content: 'Test message',
        type: 'user'
      });
      result.current.clearMessages();
    });

    expect(result.current.messages).toEqual([]);
  });
});
```

#### 1.3 é›†æˆæµ‹è¯•
```typescript
// integration/api.integration.test.ts
import { setupServer } from 'msw/node';
import { rest } from 'msw';
import { SecureAPIClient } from '../security/SecureAPIClient';

// MockæœåŠ¡å™¨è®¾ç½®
const server = setupServer(
  rest.get('/api/messages', (req, res, ctx) => {
    return res(
      ctx.status(200),
      ctx.json({
        messages: [
          { id: '1', content: 'Hello', type: 'user' },
          { id: '2', content: 'Hi', type: 'assistant' }
        ]
      })
    );
  }),

  rest.post('/api/messages', (req, res, ctx) => {
    return res(
      ctx.status(201),
      ctx.json({
        id: '3',
        content: req.body.content,
        type: 'user',
        timestamp: Date.now()
      })
    );
  }),

  rest.get('/api/auth/token', (req, res, ctx) => {
    return res(
      ctx.status(401),
      ctx.json({ error: 'Unauthorized' })
    );
  })
});

describe('API Integration Tests', () => {
  const apiClient = new SecureAPIClient('http://localhost:3000');

  beforeAll(() => server.listen());
  afterEach(() => server.resetHandlers());
  afterAll(() => server.close());

  it('fetches messages successfully', async () => {
    const response = await apiClient.get('/api/messages');

    expect(response.messages).toHaveLength(2);
    expect(response.messages[0].content).toBe('Hello');
  });

  it('sends message successfully', async () => {
    const messageData = { content: 'New message', type: 'user' };

    const response = await apiClient.post('/api/messages', messageData);

    expect(response.id).toBe('3');
    expect(response.content).toBe('New message');
  });

  it('handles authentication errors', async () => {
    await expect(apiClient.get('/api/auth/token')).rejects.toThrow('Unauthorized');
  });
});

// WebSocketé›†æˆæµ‹è¯•
// integration/websocket.integration.test.ts
import { WebSocketServer } from 'ws';
import { WebSocketManager } from '../services/WebSocketManager';

describe('WebSocket Integration Tests', () => {
  let wsServer: WebSocketServer;
  let wsManager: WebSocketManager;
  const WS_PORT = 8080;

  beforeEach(() => {
    wsServer = new WebSocketServer({ port: WS_PORT });
    wsManager = new WebSocketManager(`ws://localhost:${WS_PORT}`);
  });

  afterEach(() => {
    wsServer.close();
    wsManager.disconnect();
  });

  it('connects to WebSocket server', (done) => {
    wsServer.on('connection', (ws) => {
      expect(ws.readyState).toBe(1); // WebSocket.OPEN
      done();
    });

    wsManager.connect();
  });

  it('receives messages correctly', (done) => {
    const testMessage = { type: 'chat', content: 'Hello' };

    wsManager.onMessage((message) => {
      expect(message).toEqual(testMessage);
      done();
    });

    wsServer.on('connection', (ws) => {
      ws.send(JSON.stringify(testMessage));
    });

    wsManager.connect();
  });

  it('sends messages correctly', (done) => {
    const testMessage = { type: 'chat', content: 'Hello' };

    wsServer.on('connection', (ws) => {
      ws.on('message', (data) => {
        expect(JSON.parse(data.toString())).toEqual(testMessage);
        done();
      });
    });

    wsManager.connect();
    wsManager.sendMessage(testMessage);
  });
});
```

#### 1.4 E2Eæµ‹è¯•
```typescript
// cypress.config.ts
import { defineConfig } from 'cypress';

export default defineConfig({
  e2e: {
    baseUrl: 'http://localhost:3000',
    supportFile: 'cypress/support/e2e.ts',
    specPattern: 'cypress/e2e/**/*.cy.{js,jsx,ts,tsx}',
    viewportWidth: 1280,
    viewportHeight: 720,
    video: true,
    screenshotOnRunFailure: true,
    defaultCommandTimeout: 10000,
    requestTimeout: 10000,
    responseTimeout: 10000
  },
  component: {
    devServer: {
      framework: 'react',
      bundler: 'vite'
    }
  }
});

// cypress/e2e/chat-widget.cy.ts
describe('Chat Widget E2E Tests', () => {
  beforeEach(() => {
    cy.visit('/');
    cy.get('[data-testid="chat-widget"]').should('be.visible');
  });

  it('opens chat widget', () => {
    cy.get('[data-testid="chat-toggle"]').click();
    cy.get('[data-testid="chat-interface"]').should('be.visible');
  });

  it('sends and receives messages', () => {
    cy.get('[data-testid="chat-toggle"]').click();

    // å‘é€æ¶ˆæ¯
    cy.get('[data-testid="message-input"]')
      .type('Hello, this is a test message');
    cy.get('[data-testid="send-button"]').click();

    // éªŒè¯æ¶ˆæ¯å·²å‘é€
    cy.get('[data-testid="message-list"]')
      .should('contain', 'Hello, this is a test message');

    // ç­‰å¾…å›å¤ï¼ˆæ¨¡æ‹Ÿï¼‰
    cy.wait(2000);

    // éªŒè¯æ”¶åˆ°å›å¤
    cy.get('[data-testid="message-list"]')
      .find('[data-message-type="assistant"]')
      .should('be.visible');
  });

  it('displays typing indicator', () => {
    cy.get('[data-testid="chat-toggle"]').click();

    cy.get('[data-testid="message-input"]')
      .type('Test typing');

    cy.get('[data-testid="typing-indicator"]')
      .should('be.visible');
  });

  it('handles connection errors gracefully', () => {
    // æ¨¡æ‹Ÿç½‘ç»œé”™è¯¯
    cy.intercept('GET', '/api/health', { forceNetworkError: true });

    cy.get('[data-testid="chat-toggle"]').click();

    cy.get('[data-testid="error-message"]')
      .should('be.visible')
      .and('contain', 'Connection failed');
  });

  it('maintains message history', () => {
    cy.get('[data-testid="chat-toggle"]').click();

    // å‘é€å¤šæ¡æ¶ˆæ¯
    const messages = ['First message', 'Second message', 'Third message'];

    messages.forEach(message => {
      cy.get('[data-testid="message-input"]').clear().type(message);
      cy.get('[data-testid="send-button"]').click();
      cy.wait(500);
    });

    // éªŒè¯æ‰€æœ‰æ¶ˆæ¯éƒ½åœ¨å†å²ä¸­
    messages.forEach(message => {
      cy.get('[data-testid="message-list"]')
        .should('contain', message);
    });

    // åˆ·æ–°é¡µé¢
    cy.reload();

    // éªŒè¯æ¶ˆæ¯å†å²ä»ç„¶å­˜åœ¨
    cy.get('[data-testid="chat-toggle"]').click();
    messages.forEach(message => {
      cy.get('[data-testid="message-list"]')
        .should('contain', message);
    });
  });
});

// æ€§èƒ½æµ‹è¯•
// cypress/e2e/performance.cy.ts
describe('Performance Tests', () => {
  it('loads within performance budget', () => {
    cy.visit('/');

    // æ£€æŸ¥Core Web Vitals
    cy.getCoreWebVitals().should((vitals) => {
      expect(vitals.lcp).to.be.lessThan(2500); // Largest Contentful Paint
      expect(vitals.fid).to.be.lessThan(100);  // First Input Delay
      expect(vitals.cls).to.be.lessThan(0.1);  // Cumulative Layout Shift
    });
  });

  it('handles large message lists efficiently', () => {
    // ç”Ÿæˆå¤§é‡æ¶ˆæ¯
    const largeMessageList = Array.from({ length: 1000 }, (_, i) => ({
      id: `msg-${i}`,
      content: `Message ${i}`,
      type: i % 2 === 0 ? 'user' : 'assistant'
    }));

    cy.visit('/', {
      onBeforeLoad: (win) => {
        win.localStorage.setItem('chat-messages', JSON.stringify(largeMessageList));
      }
    });

    cy.get('[data-testid="chat-toggle"]').click();

    // éªŒè¯è™šæ‹Ÿæ»šåŠ¨å·¥ä½œæ­£å¸¸
    cy.get('[data-testid="virtual-scroll-container"]').should('be.visible');

    // éªŒè¯æ€§èƒ½
    cy.window().then((win) => {
      expect(win.performance.timing.loadEventEnd - win.performance.timing.navigationStart)
        .to.be.lessThan(3000);
    });
  });
});
```

### 2. CI/CDæµæ°´çº¿

#### 2.1 GitHub Actionsé…ç½®
```yaml
# .github/workflows/ci.yml
name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

env:
  NODE_VERSION: '18'
  CACHE_VERSION: 'v1'

jobs:
  # ä»£ç è´¨é‡æ£€æŸ¥
  quality:
    name: Code Quality
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Type check
        run: npm run type-check

      - name: ESLint
        run: npm run lint

      - name: Prettier check
        run: npm run format:check

      - name: Accessibility check
        run: npm run test:a11y

  # å•å…ƒæµ‹è¯•
  unit-tests:
    name: Unit Tests
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run unit tests
        run: npm run test:unit -- --coverage

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage/lcov.info
          flags: unittests
          name: codecov-umbrella

  # é›†æˆæµ‹è¯•
  integration-tests:
    name: Integration Tests
    runs-on: ubuntu-latest

    services:
      # æ¨¡æ‹Ÿåç«¯æœåŠ¡
      api:
        image: node:18-alpine
        ports:
          - 3001:3001
        env:
          NODE_ENV: test

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run integration tests
        run: npm run test:integration
        env:
          API_BASE_URL: http://localhost:3001

  # E2Eæµ‹è¯•
  e2e-tests:
    name: E2E Tests
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build application
        run: npm run build

      - name: Start application
        run: npm run preview &
        env:
          PORT: 3000

      - name: Wait for application
        run: npx wait-on http://localhost:3000

      - name: Run E2E tests
        uses: cypress-io/github-action@v6
        with:
          working-directory: .
          wait-on: 'http://localhost:3000'
          wait-on-timeout: 120

      - name: Upload videos
        uses: actions/upload-artifact@v4
        if: failure()
        with:
          name: cypress-videos
          path: cypress/videos

  # å®‰å…¨æ‰«æ
  security:
    name: Security Scan
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Snyk security scan
        uses: snyk/actions/node@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}

      - name: OWASP ZAP Baseline Scan
        uses: zaproxy/action-baseline@v0.7.0
        with:
          target: 'http://localhost:3000'

  # æ„å»ºå’Œéƒ¨ç½²
  build-and-deploy:
    name: Build and Deploy
    runs-on: ubuntu-latest
    needs: [quality, unit-tests, integration-tests, e2e-tests, security]

    if: github.ref == 'refs/heads/main'

    environment:
      name: production
      url: https://widget.example.com

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Create .env file
        run: |
          echo "VITE_API_BASE_URL=${{ secrets.API_BASE_URL }}" > .env.production
          echo "VITE_WS_URL=${{ secrets.WS_URL }}" >> .env.production

      - name: Build application
        run: npm run build

      - name: Optimize bundle
        run: npm run build:analyze

      - name: Deploy to Vercel
        uses: amondnet/vercel-action@v25
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.ORG_ID }}
          vercel-project-id: ${{ secrets.PROJECT_ID }}
          vercel-args: '--prod'

      - name: Run smoke tests
        run: npm run test:smoke
        env:
          BASE_URL: https://widget.example.com

  # æ€§èƒ½æµ‹è¯•
  performance:
    name: Performance Tests
    runs-on: ubuntu-latest
    needs: build-and-deploy

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Lighthouse CI
        run: |
          npm install -g @lhci/cli
          lhci autorun
        env:
          LHCI_GITHUB_APP_TOKEN: ${{ secrets.LHCI_GITHUB_APP_TOKEN }}

      - name: Run WebPageTest
        uses: webpagetest/webpagetest-action@v1
        with:
          url: https://widget.example.com
          key: ${{ secrets.WEBPAGETEST_API_KEY }}
```

#### 2.2 éƒ¨ç½²è„šæœ¬
```bash
#!/bin/bash
# scripts/deploy.sh

set -e

# é…ç½®å˜é‡
ENVIRONMENT=${1:-production}
BUILD_DIR="dist"
BACKUP_DIR="/var/backups/widget"
REMOTE_HOST="deploy@example.com"
REMOTE_PATH="/var/www/widget"

# é¢œè‰²è¾“å‡º
RED='[0;31m'
GREEN='[0;32m'
YELLOW='[1;33m'
NC='[0m'

log() {
    echo -e "${GREEN}[$(date +'%Y-%m-%d %H:%M:%S')] $1${NC}"
}

warn() {
    echo -e "${YELLOW}[$(date +'%Y-%m-%d %H:%M:%S')] WARNING: $1${NC}"
}

error() {
    echo -e "${RED}[$(date +'%Y-%m-%d %H:%M:%S')] ERROR: $1${NC}"
    exit 1
}

# æ£€æŸ¥ç¯å¢ƒ
check_environment() {
    log "Checking environment..."

    if [ ! -f ".env.${ENVIRONMENT}" ]; then
        error "Environment file .env.${ENVIRONMENT} not found"
    fi

    if ! command -v ssh &> /dev/null; then
        error "SSH client not found"
    fi

    if ! command -v rsync &> /dev/null; then
        error "rsync not found"
    fi
}

# æ„å»ºåº”ç”¨
build_application() {
    log "Building application for ${ENVIRONMENT}..."

    # åŠ è½½ç¯å¢ƒå˜é‡
    cp .env.${ENVIRONMENT} .env.production

    # å®‰è£…ä¾èµ–
    npm ci --production=false

    # æ„å»ºåº”ç”¨
    npm run build

    # éªŒè¯æ„å»ºç»“æœ
    if [ ! -d "$BUILD_DIR" ]; then
        error "Build failed - dist directory not found"
    fi

    log "Build completed successfully"
}

# è¿è¡Œæµ‹è¯•
run_tests() {
    log "Running tests..."

    # å•å…ƒæµ‹è¯•
    npm run test:unit

    # é›†æˆæµ‹è¯•
    npm run test:integration

    # çƒŸé›¾æµ‹è¯•
    npm run test:smoke

    log "All tests passed"
}

# å¤‡ä»½å½“å‰ç‰ˆæœ¬
backup_current_version() {
    log "Backing up current version..."

    ssh $REMOTE_HOST "mkdir -p $BACKUP_DIR"
    ssh $REMOTE_HOST "sudo cp -r $REMOTE_PATH $BACKUP_DIR/widget-$(date +%Y%m%d-%H%M%S)" || true

    log "Backup completed"
}

# éƒ¨ç½²åº”ç”¨
deploy_application() {
    log "Deploying application..."

    # åŒæ­¥æ–‡ä»¶
    rsync -avz --delete \
        -e "ssh -o StrictHostKeyChecking=no" \
        $BUILD_DIR/ \
        $REMOTE_HOST:$REMOTE_PATH/

    # è®¾ç½®æƒé™
    ssh $REMOTE_HOST "sudo chown -R www-data:www-data $REMOTE_PATH"
    ssh $REMOTE_HOST "sudo chmod -R 755 $REMOTE_PATH"

    # é‡å¯æœåŠ¡
    ssh $REMOTE_HOST "sudo systemctl reload nginx" || true

    log "Deployment completed"
}

# å¥åº·æ£€æŸ¥
health_check() {
    log "Running health check..."

    local url="https://widget.example.com"
    local max_attempts=30
    local attempt=1

    while [ $attempt -le $max_attempts ]; do
        if curl -f -s "$url/health" > /dev/null; then
            log "Health check passed"
            return 0
        fi

        warn "Health check attempt $attempt/$max_attempts failed"
        sleep 10
        ((attempt++))
    done

    error "Health check failed after $max_attempts attempts"
}

# å›æ»šå‡½æ•°
rollback() {
    warn "Rolling back to previous version..."

    local latest_backup=$(ssh $REMOTE_HOST "ls -t $BACKUP_DIR | head -1")

    if [ -n "$latest_backup" ]; then
        ssh $REMOTE_HOST "sudo rm -rf $REMOTE_PATH"
        ssh $REMOTE_HOST "sudo mv $BACKUP_DIR/$latest_backup $REMOTE_PATH"
        ssh $REMOTE_HOST "sudo systemctl reload nginx"

        log "Rollback completed"
    else
        error "No backup found for rollback"
    fi
}

# ä¸»æµç¨‹
main() {
    log "Starting deployment for ${ENVIRONMENT} environment"

    check_environment
    build_application
    run_tests
    backup_current_version
    deploy_application

    if health_check; then
        log "Deployment completed successfully!"
    else
        warn "Health check failed, initiating rollback..."
        rollback
        exit 1
    fi
}

# é”™è¯¯å¤„ç†
trap 'error "Deployment failed at line $LINENO"' ERR

# æ‰§è¡Œä¸»æµç¨‹
main "$@"
```

### 3. ç›‘æ§ç³»ç»Ÿ

#### 3.1 æ€§èƒ½ç›‘æ§
```typescript
// monitoring/PerformanceMonitor.ts
class PerformanceMonitor {
  private metrics: PerformanceMetric[] = [];
  private observers: PerformanceObserver[] = [];

  constructor() {
    this.initObservers();
    this.trackWebVitals();
    this.trackUserInteractions();
  }

  // åˆå§‹åŒ–æ€§èƒ½è§‚å¯Ÿå™¨
  private initObservers(): void {
    // ç›‘æ§é•¿ä»»åŠ¡
    const longTaskObserver = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        this.recordMetric({
          name: 'long-task',
          value: entry.duration,
          timestamp: entry.startTime,
          details: {
            name: (entry as PerformanceEntry).name,
            startTime: entry.startTime
          }
        });
      }
    });

    longTaskObserver.observe({ entryTypes: ['longtask'] });
    this.observers.push(longTaskObserver);

    // ç›‘æ§èµ„æºåŠ è½½
    const resourceObserver = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        this.recordMetric({
          name: 'resource-load',
          value: entry.duration,
          timestamp: entry.startTime,
          details: {
            name: entry.name,
            type: (entry as PerformanceResourceTiming).initiatorType,
            size: (entry as PerformanceResourceTiming).transferSize
          }
        });
      }
    });

    resourceObserver.observe({ entryTypes: ['resource'] });
    this.observers.push(resourceObserver);

    // ç›‘æ§å¯¼èˆª
    const navigationObserver = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        const navEntry = entry as PerformanceNavigationTiming;
        this.recordMetric({
          name: 'navigation',
          value: navEntry.loadEventEnd - navEntry.fetchStart,
          timestamp: navEntry.fetchStart,
          details: {
            domContentLoaded: navEntry.domContentLoadedEventEnd - navEntry.fetchStart,
            loadComplete: navEntry.loadEventEnd - navEntry.fetchStart,
            redirectCount: navEntry.redirectCount
          }
        });
      }
    });

    navigationObserver.observe({ entryTypes: ['navigation'] });
    this.observers.push(navigationObserver);
  }

  // Web Vitalsç›‘æ§
  private trackWebVitals(): void {
    // Largest Contentful Paint (LCP)
    this.observeLCP();

    // First Input Delay (FID)
    this.observeFID();

    // Cumulative Layout Shift (CLS)
    this.observeCLS();
  }

  private observeLCP(): void {
    new PerformanceObserver((list) => {
      const entries = list.getEntries();
      const lastEntry = entries[entries.length - 1];

      this.recordMetric({
        name: 'lcp',
        value: lastEntry.startTime,
        timestamp: Date.now(),
        details: {
          element: (lastEntry as any).element?.tagName || 'unknown',
          url: (lastEntry as any).url || ''
        }
      });
    }).observe({ entryTypes: ['largest-contentful-paint'] });
  }

  private observeFID(): void {
    new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        this.recordMetric({
          name: 'fid',
          value: (entry as any).processingStart - entry.startTime,
          timestamp: Date.now(),
          details: {
            eventType: (entry as any).name
          }
        });
      }
    }).observe({ entryTypes: ['first-input'] });
  }

  private observeCLS(): void {
    let clsValue = 0;

    new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        if (!(entry as any).hadRecentInput) {
          clsValue += (entry as any).value;

          this.recordMetric({
            name: 'cls',
            value: clsValue,
            timestamp: Date.now(),
            details: {
              value: (entry as any).value
            }
          });
        }
      }
    }).observe({ entryTypes: ['layout-shift'] });
  }

  // ç”¨æˆ·äº¤äº’ç›‘æ§
  private trackUserInteractions(): void {
    // ç‚¹å‡»å“åº”æ—¶é—´
    document.addEventListener('click', (event) => {
      const target = event.target as HTMLElement;
      const startTime = performance.now();

      requestAnimationFrame(() => {
        const responseTime = performance.now() - startTime;

        this.recordMetric({
          name: 'click-response',
          value: responseTime,
          timestamp: Date.now(),
          details: {
            tagName: target.tagName,
            className: target.className,
            id: target.id
          }
        });
      });
    });

    // è¡¨å•æäº¤æ—¶é—´
    document.addEventListener('submit', (event) => {
      const form = event.target as HTMLFormElement;
      const startTime = performance.now();

      // ç›‘å¬è¡¨å•æäº¤å®Œæˆ
      const observer = new MutationObserver(() => {
        const submitTime = performance.now() - startTime;

        this.recordMetric({
          name: 'form-submit',
          value: submitTime,
          timestamp: Date.now(),
          details: {
            formId: form.id,
            formName: form.name
          }
        });

        observer.disconnect();
      });

      observer.observe(document.body, { childList: true, subtree: true });
    });
  }

  // è®°å½•æŒ‡æ ‡
  private recordMetric(metric: PerformanceMetric): void {
    this.metrics.push(metric);

    // ä¿æŒæŒ‡æ ‡æ•°é‡åœ¨åˆç†èŒƒå›´å†…
    if (this.metrics.length > 1000) {
      this.metrics = this.metrics.slice(-500);
    }

    // å‘é€åˆ°ç›‘æ§æœåŠ¡
    this.sendMetric(metric);
  }

  // è‡ªå®šä¹‰æŒ‡æ ‡è®°å½•
  recordCustomMetric(name: string, value: number, details?: any): void {
    this.recordMetric({
      name,
      value,
      timestamp: Date.now(),
      details: details || {}
    });
  }

  // å‘é€æŒ‡æ ‡åˆ°æœåŠ¡å™¨
  private async sendMetric(metric: PerformanceMetric): Promise<void> {
    try {
      await fetch('/api/metrics', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(metric)
      });
    } catch (error) {
      console.error('Failed to send metric:', error);
    }
  }

  // è·å–æ€§èƒ½æŠ¥å‘Š
  getPerformanceReport(): PerformanceReport {
    const now = Date.now();
    const last24Hours = this.metrics.filter(m => now - m.timestamp < 86400000);

    return {
      totalMetrics: this.metrics.length,
      last24Hours: last24Hours.length,
      webVitals: this.getWebVitals(last24Hours),
      resourceMetrics: this.getResourceMetrics(last24Hours),
      userInteractionMetrics: this.getUserInteractionMetrics(last24Hours),
      recommendations: this.generateRecommendations(last24Hours)
    };
  }

  private getWebVitals(metrics: PerformanceMetric[]): WebVitals {
    const lcp = metrics.find(m => m.name === 'lcp');
    const fid = metrics.find(m => m.name === 'fid');
    const cls = metrics.find(m => m.name === 'cls');

    return {
      lcp: lcp?.value || 0,
      fid: fid?.value || 0,
      cls: cls?.value || 0,
      lcpRating: this.getLCPRating(lcp?.value || 0),
      fidRating: this.getFIDRating(fid?.value || 0),
      clsRating: this.getCLSRating(cls?.value || 0)
    };
  }

  private getResourceMetrics(metrics: PerformanceMetric[]): ResourceMetrics {
    const resourceMetrics = metrics.filter(m => m.name === 'resource-load');

    const totalLoadTime = resourceMetrics.reduce((sum, m) => sum + m.value, 0);
    const totalSize = resourceMetrics.reduce((sum, m) => sum + (m.details.size || 0), 0);

    return {
      averageLoadTime: resourceMetrics.length > 0 ? totalLoadTime / resourceMetrics.length : 0,
      totalResources: resourceMetrics.length,
      totalSize,
      slowResources: resourceMetrics.filter(m => m.value > 1000).length
    };
  }

  private getUserInteractionMetrics(metrics: PerformanceMetric[]): UserInteractionMetrics {
    const clickMetrics = metrics.filter(m => m.name === 'click-response');
    const formMetrics = metrics.filter(m => m.name === 'form-submit');

    return {
      averageClickResponse: clickMetrics.length > 0
        ? clickMetrics.reduce((sum, m) => sum + m.value, 0) / clickMetrics.length
        : 0,
      averageFormSubmit: formMetrics.length > 0
        ? formMetrics.reduce((sum, m) => sum + m.value, 0) / formMetrics.length
        : 0,
      totalInteractions: clickMetrics.length + formMetrics.length
    };
  }

  private generateRecommendations(metrics: PerformanceMetric[]): string[] {
    const recommendations: string[] = [];

    const lcp = metrics.find(m => m.name === 'lcp');
    if (lcp && lcp.value > 2500) {
      recommendations.push('ä¼˜åŒ–LCPæ—¶é—´ï¼šè€ƒè™‘ä¼˜åŒ–å›¾ç‰‡åŠ è½½ã€å‡å°‘æœåŠ¡å™¨å“åº”æ—¶é—´');
    }

    const cls = metrics.find(m => m.name === 'cls');
    if (cls && cls.value > 0.1) {
      recommendations.push('å‡å°‘CLSï¼šä¸ºå›¾ç‰‡å’Œå¹¿å‘Šè®¾ç½®æ˜ç¡®å°ºå¯¸ï¼Œé¿å…å†…å®¹åç§»');
    }

    const slowResources = metrics.filter(m => m.name === 'resource-load' && m.value > 1000);
    if (slowResources.length > 0) {
      recommendations.push(`å‘ç°${slowResources.length}ä¸ªæ…¢åŠ è½½èµ„æºï¼Œå»ºè®®ä¼˜åŒ–æˆ–ç¼“å­˜`);
    }

    return recommendations;
  }

  private getLCPRating(value: number): 'good' | 'needs-improvement' | 'poor' {
    if (value <= 2500) return 'good';
    if (value <= 4000) return 'needs-improvement';
    return 'poor';
  }

  private getFIDRating(value: number): 'good' | 'needs-improvement' | 'poor' {
    if (value <= 100) return 'good';
    if (value <= 300) return 'needs-improvement';
    return 'poor';
  }

  private getCLSRating(value: number): 'good' | 'needs-improvement' | 'poor' {
    if (value <= 0.1) return 'good';
    if (value <= 0.25) return 'needs-improvement';
    return 'poor';
  }

  // æ¸…ç†èµ„æº
  destroy(): void {
    this.observers.forEach(observer => observer.disconnect());
    this.observers = [];
  }
}

// æ¥å£å®šä¹‰
interface PerformanceMetric {
  name: string;
  value: number;
  timestamp: number;
  details: any;
}

interface PerformanceReport {
  totalMetrics: number;
  last24Hours: number;
  webVitals: WebVitals;
  resourceMetrics: ResourceMetrics;
  userInteractionMetrics: UserInteractionMetrics;
  recommendations: string[];
}

interface WebVitals {
  lcp: number;
  fid: number;
  cls: number;
  lcpRating: 'good' | 'needs-improvement' | 'poor';
  fidRating: 'good' | 'needs-improvement' | 'poor';
  clsRating: 'good' | 'needs-improvement' | 'poor';
}

interface ResourceMetrics {
  averageLoadTime: number;
  totalResources: number;
  totalSize: number;
  slowResources: number;
}

interface UserInteractionMetrics {
  averageClickResponse: number;
  averageFormSubmit: number;
  totalInteractions: number;
}

export { PerformanceMonitor };
```

#### 3.2 é”™è¯¯ç›‘æ§
```typescript
// monitoring/ErrorMonitor.ts
class ErrorMonitor {
  private errors: ErrorEvent[] = [];
  private readonly MAX_ERRORS = 100;

  constructor() {
    this.setupGlobalHandlers();
    this.setupUnhandledRejectionHandler();
  }

  // è®¾ç½®å…¨å±€é”™è¯¯å¤„ç†
  private setupGlobalHandlers(): void {
    window.addEventListener('error', (event) => {
      this.recordError({
        type: 'javascript',
        message: event.message,
        filename: event.filename,
        lineno: event.lineno,
        colno: event.colno,
        stack: event.error?.stack,
        timestamp: Date.now(),
        userAgent: navigator.userAgent,
        url: window.location.href
      });
    });

    window.addEventListener('error', (event) => {
      if (event.target !== window) {
        this.recordError({
          type: 'resource',
          message: `Failed to load resource: ${(event.target as any)?.src || (event.target as any)?.href}`,
          element: (event.target as any)?.tagName,
          source: (event.target as any)?.src || (event.target as any)?.href,
          timestamp: Date.now(),
          userAgent: navigator.userAgent,
          url: window.location.href
        });
      }
    }, true);
  }

  // å¤„ç†æœªæ•è·çš„Promiseæ‹’ç»
  private setupUnhandledRejectionHandler(): void {
    window.addEventListener('unhandledrejection', (event) => {
      this.recordError({
        type: 'promise-rejection',
        message: event.reason?.message || 'Unhandled promise rejection',
        stack: event.reason?.stack,
        timestamp: Date.now(),
        userAgent: navigator.userAgent,
        url: window.location.href
      });
    });
  }

  // è®°å½•é”™è¯¯
  private recordError(error: ErrorEvent): void {
    this.errors.push(error);

    // ä¿æŒé”™è¯¯é˜Ÿåˆ—å¤§å°
    if (this.errors.length > this.MAX_ERRORS) {
      this.errors.shift();
    }

    // å‘é€é”™è¯¯åˆ°æœåŠ¡å™¨
    this.reportError(error);
  }

  // æ‰‹åŠ¨æŠ¥å‘Šé”™è¯¯
  reportError(error: ErrorEvent | Error | string, context?: any): void {
    let errorEvent: ErrorEvent;

    if (typeof error === 'string') {
      errorEvent = {
        type: 'manual',
        message: error,
        timestamp: Date.now(),
        userAgent: navigator.userAgent,
        url: window.location.href,
        context
      };
    } else if (error instanceof Error) {
      errorEvent = {
        type: 'manual',
        message: error.message,
        stack: error.stack,
        timestamp: Date.now(),
        userAgent: navigator.userAgent,
        url: window.location.href,
        context
      };
    } else {
      errorEvent = {
        ...error,
        timestamp: Date.now(),
        userAgent: navigator.userAgent,
        url: window.location.href
      };
    }

    this.recordError(errorEvent);
  }

  // å‘é€é”™è¯¯åˆ°æœåŠ¡å™¨
  private async reportError(error: ErrorEvent): Promise<void> {
    try {
      await fetch('/api/errors', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(error)
      });
    } catch (reportError) {
      console.error('Failed to report error:', reportError);
    }
  }

  // è·å–é”™è¯¯æŠ¥å‘Š
  getErrorReport(): ErrorReport {
    const now = Date.now();
    const last24Hours = this.errors.filter(e => now - e.timestamp < 86400000);

    return {
      totalErrors: this.errors.length,
      last24Hours: last24Hours.length,
      errorTypes: this.getErrorTypeDistribution(last24Hours),
      criticalErrors: last24Hours.filter(e => this.isCriticalError(e)).length,
      recommendations: this.generateErrorRecommendations(last24Hours)
    };
  }

  private getErrorTypeDistribution(errors: ErrorEvent[]): Record<string, number> {
    return errors.reduce((acc, error) => {
      acc[error.type] = (acc[error.type] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);
  }

  private isCriticalError(error: ErrorEvent): boolean {
    const criticalTypes = ['javascript', 'promise-rejection'];
    return criticalTypes.includes(error.type);
  }

  private generateErrorRecommendations(errors: ErrorEvent[]): string[] {
    const recommendations: string[] = [];

    const jsErrors = errors.filter(e => e.type === 'javascript');
    if (jsErrors.length > 10) {
      recommendations.push('JavaScripté”™è¯¯è¾ƒå¤šï¼Œå»ºè®®åŠ å¼ºä»£ç æµ‹è¯•å’Œé”™è¯¯å¤„ç†');
    }

    const resourceErrors = errors.filter(e => e.type === 'resource');
    if (resourceErrors.length > 5) {
      recommendations.push('èµ„æºåŠ è½½é”™è¯¯è¾ƒå¤šï¼Œå»ºè®®æ£€æŸ¥èµ„æºURLå’ŒæœåŠ¡å™¨çŠ¶æ€');
    }

    return recommendations;
  }
}

interface ErrorEvent {
  type: string;
  message: string;
  filename?: string;
  lineno?: number;
  colno?: number;
  stack?: string;
  element?: string;
  source?: string;
  timestamp: number;
  userAgent: string;
  url: string;
  context?: any;
}

interface ErrorReport {
  totalErrors: number;
  last24Hours: number;
  errorTypes: Record<string, number>;
  criticalErrors: number;
  recommendations: string[];
}

export { ErrorMonitor };
```

#### 3.3 ç›‘æ§ä»ªè¡¨æ¿
```typescript
// monitoring/Dashboard.tsx
import React, { useState, useEffect } from 'react';
import { PerformanceMonitor } from './PerformanceMonitor';
import { ErrorMonitor } from './ErrorMonitor';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from 'recharts';

interface MonitoringDashboardProps {
  apiBaseUrl: string;
}

const MonitoringDashboard: React.FC<MonitoringDashboardProps> = ({ apiBaseUrl }) => {
  const [performanceData, setPerformanceData] = useState<any[]>([]);
  const [errorData, setErrorData] = useState<any[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [timeRange, setTimeRange] = useState('24h');

  useEffect(() => {
    const performanceMonitor = new PerformanceMonitor();
    const errorMonitor = new ErrorMonitor();

    const fetchData = async () => {
      try {
        const [perfResponse, errorResponse] = await Promise.all([
          fetch(`${apiBaseUrl}/metrics/summary?range=${timeRange}`),
          fetch(`${apiBaseUrl}/errors/summary?range=${timeRange}`)
        ]);

        const perfData = await perfResponse.json();
        const errorData = await errorResponse.json();

        setPerformanceData(perfData.metrics);
        setErrorData(errorData.errors);
      } catch (error) {
        console.error('Failed to fetch monitoring data:', error);
      } finally {
        setIsLoading(false);
      }
    };

    fetchData();
    const interval = setInterval(fetchData, 60000); // æ¯åˆ†é’Ÿåˆ·æ–°

    return () => {
      clearInterval(interval);
      performanceMonitor.destroy();
    };
  }, [apiBaseUrl, timeRange]);

  if (isLoading) {
    return <div className="flex justify-center items-center h-64">Loading monitoring data...</div>;
  }

  return (
    <div className="monitoring-dashboard p-6">
      <div className="mb-6">
        <h1 className="text-2xl font-bold mb-4">ç³»ç»Ÿç›‘æ§ä»ªè¡¨æ¿</h1>

        {/* æ—¶é—´èŒƒå›´é€‰æ‹©å™¨ */}
        <div className="flex space-x-2 mb-6">
          {['1h', '6h', '24h', '7d'].map(range => (
            <button
              key={range}
              onClick={() => setTimeRange(range)}
              className={`px-4 py-2 rounded ${
                timeRange === range
                  ? 'bg-blue-500 text-white'
                  : 'bg-gray-200 text-gray-700'
              }`}
            >
              {range}
            </button>
          ))}
        </div>
      </div>

      {/* æ€§èƒ½æŒ‡æ ‡å¡ç‰‡ */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
        <MetricCard
          title="å¹³å‡LCP"
          value={performanceData.lcp?.average || 0}
          unit="ms"
          status={getLCPStatus(performanceData.lcp?.average || 0)}
        />
        <MetricCard
          title="å¹³å‡FID"
          value={performanceData.fid?.average || 0}
          unit="ms"
          status={getFIDStatus(performanceData.fid?.average || 0)}
        />
        <MetricCard
          title="å¹³å‡CLS"
          value={performanceData.cls?.average || 0}
          unit=""
          status={getCLSStatus(performanceData.cls?.average || 0)}
        />
        <MetricCard
          title="é”™è¯¯ç‡"
          value={errorData.errorRate || 0}
          unit="%"
          status={getErrorStatus(errorData.errorRate || 0)}
        />
      </div>

      {/* å›¾è¡¨åŒºåŸŸ */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
        {/* æ€§èƒ½è¶‹åŠ¿å›¾ */}
        <div className="bg-white p-6 rounded-lg shadow">
          <h2 className="text-lg font-semibold mb-4">æ€§èƒ½è¶‹åŠ¿</h2>
          <ResponsiveContainer width="100%" height={300}>
            <LineChart data={performanceData.trend}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis dataKey="time" />
              <YAxis />
              <Tooltip />
              <Line
                type="monotone"
                dataKey="lcp"
                stroke="#8884d8"
                name="LCP (ms)"
              />
              <Line
                type="monotone"
                dataKey="fid"
                stroke="#82ca9d"
                name="FID (ms)"
              />
            </LineChart>
          </ResponsiveContainer>
        </div>

        {/* é”™è¯¯è¶‹åŠ¿å›¾ */}
        <div className="bg-white p-6 rounded-lg shadow">
          <h2 className="text-lg font-semibold mb-4">é”™è¯¯è¶‹åŠ¿</h2>
          <ResponsiveContainer width="100%" height={300}>
            <LineChart data={errorData.trend}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis dataKey="time" />
              <YAxis />
              <Tooltip />
              <Line
                type="monotone"
                dataKey="count"
                stroke="#ff7300"
                name="é”™è¯¯æ•°é‡"
              />
            </LineChart>
          </ResponsiveContainer>
        </div>
      </div>

      {/* è¯¦ç»†ä¿¡æ¯è¡¨æ ¼ */}
      <div className="bg-white p-6 rounded-lg shadow">
        <h2 className="text-lg font-semibold mb-4">æœ€è¿‘é”™è¯¯</h2>
        <div className="overflow-x-auto">
          <table className="min-w-full divide-y divide-gray-200">
            <thead className="bg-gray-50">
              <tr>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  æ—¶é—´
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  ç±»å‹
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  æ¶ˆæ¯
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  é¢‘æ¬¡
                </th>
              </tr>
            </thead>
            <tbody className="bg-white divide-y divide-gray-200">
              {errorData.recent?.map((error: any, index: number) => (
                <tr key={index}>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                    {new Date(error.timestamp).toLocaleString()}
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                    <span className={`px-2 py-1 rounded text-xs ${
                      error.type === 'javascript' ? 'bg-red-100 text-red-800' :
                      error.type === 'resource' ? 'bg-yellow-100 text-yellow-800' :
                      'bg-gray-100 text-gray-800'
                    }`}>
                      {error.type}
                    </span>
                  </td>
                  <td className="px-6 py-4 text-sm text-gray-900 max-w-xs truncate">
                    {error.message}
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                    {error.count}
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </div>
    </div>
  );
};

// æŒ‡æ ‡å¡ç‰‡ç»„ä»¶
interface MetricCardProps {
  title: string;
  value: number;
  unit: string;
  status: 'good' | 'warning' | 'critical';
}

const MetricCard: React.FC<MetricCardProps> = ({ title, value, unit, status }) => {
  const statusColors = {
    good: 'bg-green-100 text-green-800',
    warning: 'bg-yellow-100 text-yellow-800',
    critical: 'bg-red-100 text-red-800'
  };

  return (
    <div className="bg-white p-6 rounded-lg shadow">
      <h3 className="text-sm font-medium text-gray-500 mb-2">{title}</h3>
      <div className="flex items-baseline">
        <span className="text-2xl font-semibold text-gray-900">
          {value.toFixed(unit === '' ? 3 : 0)}
        </span>
        <span className="ml-1 text-sm text-gray-500">{unit}</span>
      </div>
      <div className="mt-2">
        <span className={`inline-flex px-2 py-1 text-xs font-medium rounded-full ${statusColors[status]}`}>
          {status}
        </span>
      </div>
    </div>
  );
};

// çŠ¶æ€åˆ¤æ–­å‡½æ•°
const getLCPStatus = (value: number): 'good' | 'warning' | 'critical' => {
  if (value <= 2500) return 'good';
  if (value <= 4000) return 'warning';
  return 'critical';
};

const getFIDStatus = (value: number): 'good' | 'warning' | 'critical' => {
  if (value <= 100) return 'good';
  if (value <= 300) return 'warning';
  return 'critical';
};

const getCLSStatus = (value: number): 'good' | 'warning' | 'critical' => {
  if (value <= 0.1) return 'good';
  if (value <= 0.25) return 'warning';
  return 'critical';
};

const getErrorStatus = (value: number): 'good' | 'warning' | 'critical' => {
  if (value <= 1) return 'good';
  if (value <= 5) return 'warning';
  return 'critical';
};

export { MonitoringDashboard };
```

## æŠ€æœ¯æ–¹æ¡ˆ

### æµ‹è¯•æ¡†æ¶
- **å•å…ƒæµ‹è¯•**: Jest + React Testing Library
- **é›†æˆæµ‹è¯•**: MSW (Mock Service Worker)
- **E2Eæµ‹è¯•**: Cypress
- **æ€§èƒ½æµ‹è¯•**: Lighthouse CI
- **å®‰å…¨æµ‹è¯•**: OWASP ZAP, Snyk

### CI/CDå·¥å…·
- **ç‰ˆæœ¬æ§åˆ¶**: GitHub
- **CI/CD**: GitHub Actions
- **éƒ¨ç½²**: Vercel, AWS S3/CloudFront
- **ç›‘æ§**: DataDog, Sentry
- **é€šçŸ¥**: Slack, Email

### ç›‘æ§æŠ€æœ¯æ ˆ
- **æ€§èƒ½ç›‘æ§**: Web Vitals, Performance API
- **é”™è¯¯ç›‘æ§**: Sentry, è‡ªå®šä¹‰é”™è¯¯è¿½è¸ª
- **ç”¨æˆ·ä½“éªŒç›‘æ§**: RUM (Real User Monitoring)
- **ä¸šåŠ¡æŒ‡æ ‡**: è‡ªå®šä¹‰æŒ‡æ ‡æ”¶é›†

## å¼€å‘è®¡åˆ’

### ç¬¬1å‘¨ï¼šæµ‹è¯•æ¡†æ¶æ­å»º
- Jestå’ŒTesting Libraryé…ç½®
- åŸºç¡€å•å…ƒæµ‹è¯•ç¼–å†™
- MockæœåŠ¡è®¾ç½®

### ç¬¬2å‘¨ï¼šCI/CDæµæ°´çº¿
- GitHub Actionsé…ç½®
- è‡ªåŠ¨åŒ–æµ‹è¯•é›†æˆ
- åŸºç¡€éƒ¨ç½²æµç¨‹

### ç¬¬3å‘¨ï¼šç›‘æ§ç³»ç»Ÿ
- æ€§èƒ½ç›‘æ§å®ç°
- é”™è¯¯ç›‘æ§é›†æˆ
- ç›‘æ§ä»ªè¡¨æ¿å¼€å‘

### ç¬¬4å‘¨ï¼šå®Œå–„å’Œä¼˜åŒ–
- æµ‹è¯•è¦†ç›–ç‡æå‡
- CI/CDæµç¨‹ä¼˜åŒ–
- ç›‘æ§å‘Šè­¦å®Œå–„

## é£é™©å’Œä¾èµ–

### æŠ€æœ¯é£é™©
- æµ‹è¯•ç¯å¢ƒé…ç½®å¤æ‚
- CI/CDæµæ°´çº¿ç¨³å®šæ€§
- ç›‘æ§æ•°æ®å‡†ç¡®æ€§

### ä¾èµ–å…³ç³»
- ä¾èµ–æ‰€æœ‰åŠŸèƒ½æ¨¡å—å®Œæˆ
- éœ€è¦æµ‹è¯•ç¯å¢ƒæ”¯æŒ
- éœ€è¦ç›‘æ§æœåŠ¡é…ç½®

## æµ‹è¯•ç­–ç•¥

### è‡ªåŠ¨åŒ–æµ‹è¯•
- ä»£ç æäº¤è§¦å‘æµ‹è¯•
- å®šæ—¶æ‰§è¡Œå®Œæ•´æµ‹è¯•å¥—ä»¶
- æ€§èƒ½å›å½’æµ‹è¯•
- å®‰å…¨æ‰«æè‡ªåŠ¨åŒ–

### æ‰‹åŠ¨æµ‹è¯•
- UATç”¨æˆ·éªŒæ”¶æµ‹è¯•
- å…¼å®¹æ€§æµ‹è¯•
- ç”¨æˆ·ä½“éªŒæµ‹è¯•

## éƒ¨ç½²å’Œç›‘æ§

### éƒ¨ç½²ç­–ç•¥
- è“ç»¿éƒ¨ç½²
- é‡‘ä¸é›€å‘å¸ƒ
- è‡ªåŠ¨å›æ»šæœºåˆ¶

### ç›‘æ§å‘Šè­¦
- å®æ—¶æ€§èƒ½ç›‘æ§
- é”™è¯¯ç‡å‘Šè­¦
- ç”¨æˆ·ä½“éªŒæŒ‡æ ‡è¿½è¸ª
- ä¸šåŠ¡æŒ‡æ ‡ç›‘æ§
